<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · HurdleDMR.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-4385132-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://asafmanela.github.io/HurdleDMR.jl/stable/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>HurdleDMR.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Setup-1">Setup</a></li><li><a class="toctext" href="#Distributed-Multinomial-Regression-(DMR)-1">Distributed Multinomial Regression (DMR)</a></li><li><a class="toctext" href="#Hurdle-Distributed-Multinomial-Regression-(HDMR)-1">Hurdle Distributed Multinomial Regression (HDMR)</a></li><li><a class="toctext" href="#Sufficient-reduction-projection-1">Sufficient reduction projection</a></li><li><a class="toctext" href="#Counts-Inverse-Regression-(CIR)-1">Counts Inverse Regression (CIR)</a></li><li><a class="toctext" href="#Hurdle-1">Hurdle</a></li><li><a class="toctext" href="#Positive-Poisson-1">Positive Poisson</a></li><li><a class="toctext" href="#API-/-Index-1">API / Index</a></li></ul></li><li><a class="toctext" href="tutorials/">Tutorials</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/AsafManela/HurdleDMR.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="HurdleDMR.jl-1" href="#HurdleDMR.jl-1">HurdleDMR.jl</a></h1><p>HurdleDMR.jl is a Julia implementation of the Hurdle Distributed Multinomial Regression (HDMR), as described in:</p><p>Kelly, Bryan, Asaf Manela, and Alan Moreira (2018). Text Selection. <a href="http://apps.olin.wustl.edu/faculty/manela/kmm/textselection/">Working paper</a>.</p><p>It includes a Julia implementation of the Distributed Multinomial Regression (DMR) model of <a href="https://arxiv.org/abs/1311.6139">Taddy (2015)</a>.</p><h2><a class="nav-anchor" id="Setup-1" href="#Setup-1">Setup</a></h2><p>Install the HurdleDMR package, switch to Pkg mode (hit ])</p><pre><code class="language-julia">pkg&gt; add HurdleDMR</code></pre><p>Add parallel workers and make package available to workers</p><pre><code class="language-julia">using Distributed
addprocs(4)
import HurdleDMR; @everywhere using HurdleDMR</code></pre><p>Setup your data into an n-by-p covars matrix, and a (sparse) n-by-d counts matrix. Here we generate some random data.</p><pre><code class="language-julia">using CSV, GLM, DataFrames, Distributions, Random, LinearAlgebra, SparseArrays
n = 100
p = 3
d = 4

Random.seed!(13)
m = 1 .+ rand(Poisson(5),n)
covars = rand(n,p)
ηfn(vi) = exp.([0 + i*sum(vi) for i=1:d])
q = [ηfn(covars[i,:]) for i=1:n]
rmul!.(q,ones(n)./sum.(q))
counts = convert(SparseMatrixCSC{Float64,Int},hcat(broadcast((qi,mi)-&gt;rand(Multinomial(mi, qi)),q,m)...)&#39;)
covarsdf = DataFrame(covars,[:vy, :v1, :v2])</code></pre><h2><a class="nav-anchor" id="Distributed-Multinomial-Regression-(DMR)-1" href="#Distributed-Multinomial-Regression-(DMR)-1">Distributed Multinomial Regression (DMR)</a></h2><p>The Distributed Multinomial Regression (DMR) model of Taddy (2015) is a highly scalable approximation to the Multinomial using distributed (independent, parallel) Poisson regressions, one for each of the d categories (columns) of a large <code>counts</code> matrix, on the <code>covars</code>.</p><p>To fit a DMR:</p><pre><code class="language-julia">m = dmr(covars, counts)</code></pre><p>or with a dataframe and formula</p><pre><code class="language-julia">mf = @model(c ~ vy + v1 + v2)
m = fit(DMR, mf, covarsdf, counts)</code></pre><p>in either case we can get the coefficients matrix for each variable + intercept as usual with</p><pre><code class="language-julia">coef(m)</code></pre><p>By default we only return the AICc maximizing coefficients. To also get back the entire regulatrization paths, run</p><pre><code class="language-julia">paths = fit(DMRPaths, mf, covarsdf, counts)</code></pre><p>we can now select, for example the coefficients that minimize 10-fold CV mse (takes a while)</p><pre><code class="language-julia">coef(paths, MinCVKfold{MinCVmse}(10))</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.DCR" href="#HurdleDMR.DCR"><code>HurdleDMR.DCR</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract Distributed Counts Regression (DCR) returned object</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.DMR" href="#HurdleDMR.DMR"><code>HurdleDMR.DMR</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract DMR returned object</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.DMRCoefs" href="#HurdleDMR.DMRCoefs"><code>HurdleDMR.DMRCoefs</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Relatively light object used to return DMR results when we only care about estimated coefficients.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L25-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.DMRPaths" href="#HurdleDMR.DMRPaths"><code>HurdleDMR.DMRPaths</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Relatively heavy object used to return DMR results when we care about the regulatrization paths.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L11-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Distributions.ncategories-Tuple{DCR}" href="#Distributions.ncategories-Tuple{DCR}"><code>Distributions.ncategories</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Number of categories (terms/words/phrases) used for DMR estimation</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.dmr-Union{Tuple{V}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{V,2}}} where V where T&lt;:AbstractFloat" href="#HurdleDMR.dmr-Union{Tuple{V}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{V,2}}} where V where T&lt;:AbstractFloat"><code>HurdleDMR.dmr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Shorthand for fit(DMR,covars,counts). See also <a href="#StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat"><code>fit(::DMR)</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L420">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.dmrpaths-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2} where T}} where T&lt;:AbstractFloat" href="#HurdleDMR.dmrpaths-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2} where T}} where T&lt;:AbstractFloat"><code>HurdleDMR.dmrpaths</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Shorthand for fit(DMRPaths,covars,counts). See also <a href="#StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat"><code>fit(::DMRPaths)</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.hasintercept-Tuple{DCR}" href="#HurdleDMR.hasintercept-Tuple{DCR}"><code>HurdleDMR.hasintercept</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Whether the model includes an intercept in each independent counts (e.g. hurdle) regression</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L193">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.ncoefs-Tuple{DMR}" href="#HurdleDMR.ncoefs-Tuple{DMR}"><code>HurdleDMR.ncoefs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Number of coefficient potentially including intercept used for each independent Poisson regression</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.ncovars-Tuple{DMR}" href="#HurdleDMR.ncovars-Tuple{DMR}"><code>HurdleDMR.ncovars</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Number of covariates used for DMR estimation</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.coef-Tuple{DMRCoefs}" href="#StatsBase.coef-Tuple{DMRCoefs}"><code>StatsBase.coef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">coef(m::DMRCoefs)</code></pre><p>Returns the coefficient matrices fitted with DMR using the segment selected during fit (MinAICc by default).</p><p><strong>Example:</strong></p><pre><code class="language-julia">  m = fit(DMR,covars,counts)
  coef(m)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L115-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat" href="#StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(DMR,covars,counts; &lt;keyword arguments&gt;)
dmr(covars,counts; &lt;keyword arguments&gt;)</code></pre><p>Fit a Distributed Multinomial Regression (DMR) of counts on covars.</p><p>DMR fits independent poisson gamma lasso regressions to each column of counts to approximate a multinomial, picks a segement of each path, and returns a coefficient matrix (wrapped in DMRCoefs) representing point estimates for the entire multinomial (includes the intercept if one was included).</p><p><strong>Example:</strong></p><pre><code class="language-julia">  m = fit(DMR,covars,counts)</code></pre><p><strong>Arguments</strong></p><ul><li><code>covars</code> n-by-p matrix of covariates</li><li><code>counts</code> n-by-d matrix of counts (usually sparse)</li></ul><p><strong>Keywords</strong></p><ul><li><code>intercept::Bool=false</code> include an intercept in each poisson</li><li><code>parallel::Bool=true</code> parallelize the poisson fits</li><li><code>local_cluster::Bool=true</code> use local_cluster mode that shares memory across   parallel workers that is appropriate on a single multicore machine, or   remote cluster mode that is more appropriate when distributing across machines   for which sharing memory is costly.</li><li><code>verbose::Bool=true</code></li><li><code>showwarnings::Bool=false</code></li><li><code>select::SegSelect=MinAICc()</code> which path segment to pick</li><li><code>kwargs...</code> additional keyword arguments passed along to fit(GammaLassoPath,...)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L42-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{T}, Tuple{Type{DMRPaths},AbstractArray{T,2},AbstractArray{T,2} where T}} where T&lt;:AbstractFloat" href="#StatsBase.fit-Union{Tuple{T}, Tuple{Type{DMRPaths},AbstractArray{T,2},AbstractArray{T,2} where T}} where T&lt;:AbstractFloat"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(DMRPaths,covars,counts; &lt;keyword arguments&gt;)
dmrpaths(covars,counts; &lt;keyword arguments&gt;)</code></pre><p>Fit a Distributed Multinomial Regression (DMR) of counts on covars, and returns the entire regulatrization paths, which may be useful for plotting or picking coefficients other than the AICc optimal ones. Same arguments as <a href="#StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat"><code>fit(::DMR)</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L79-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{T}, Tuple{Type{T},Model,Any,AbstractArray{T,2} where T}} where T&lt;:DMR" href="#StatsBase.fit-Union{Tuple{T}, Tuple{Type{T},Model,Any,AbstractArray{T,2} where T}} where T&lt;:DMR"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(DMR,@model(c ~ x1*x2),df,counts; &lt;keyword arguments&gt;)</code></pre><p>Fits a DMR but takes a model formula and dataframe instead of the covars matrix. See also <a href="#StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat"><code>fit(::DMR)</code></a>.</p><p><code>c</code> must be specified on the lhs to indicate the model for counts.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L94-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.nobs-Tuple{DCR}" href="#StatsBase.nobs-Tuple{DCR}"><code>StatsBase.nobs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Number of observations used. May be lower than provided after removing all zero obs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.predict-Union{Tuple{T}, Tuple{DMRPaths,AbstractArray{T,2}}} where T&lt;:AbstractFloat" href="#StatsBase.predict-Union{Tuple{T}, Tuple{DMRPaths,AbstractArray{T,2}}} where T&lt;:AbstractFloat"><code>StatsBase.predict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">predict(m,newcovars; &lt;keyword arguments&gt;)</code></pre><p>Predict counts using a fitted DMRPaths object and given newcovars.</p><p><strong>Example:</strong></p><pre><code class="language-julia">  m = fit(DMRPaths,covars,counts)
  newcovars = covars[1:10,:]
  countshat = predict(m, newcovars; select=MinAICc())</code></pre><p><strong>Arguments</strong></p><ul><li><code>m::DMRPaths</code> fitted DMRPaths model (DMRCoefs currently not supported)</li><li><code>newcovars</code> n-by-p matrix of covariates of same dimensions used to fit m.</li></ul><p><strong>Keywords</strong></p><ul><li><code>select=MinAICc()</code> See <a href="#StatsBase.coef-Tuple{DMRCoefs}"><code>coef(::RegularizationPath)</code></a>.</li><li><code>kwargs...</code> additional keyword arguments passed along to predict() for each category j=1..size(counts,2)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/dmr.jl#L449-L469">source</a></section><h2><a class="nav-anchor" id="Hurdle-Distributed-Multinomial-Regression-(HDMR)-1" href="#Hurdle-Distributed-Multinomial-Regression-(HDMR)-1">Hurdle Distributed Multinomial Regression (HDMR)</a></h2><p>For highly sparse counts, as is often the case with text that is selected for various reasons, the Hurdle Distributed Multinomial Regression (HDMR) model of Kelly, Manela, and Moreira (2018), may be superior to the DMR. It approximates a higher dispersion Multinomial using distributed (independent, parallel) Hurdle regressions, one for each of the d categories (columns) of a large <code>counts</code> matrix, on the <code>covars</code>. It allows a potentially different sets of covariates to explain category inclusion (<span>$h=1{c&gt;0}$</span>), and repetition (<span>$c&gt;0$</span>).</p><p>Both the model for zeroes and for positive counts are regularized by default, using <a href="@ref"><code>GammaLassoPath</code></a>, picking the AICc optimal segment of the regularization path.</p><p>HDMR can be fitted:</p><pre><code class="language-julia">m = hdmr(covars, counts; inpos=1:2, inzero=1:3)</code></pre><p>or with a dataframe and formula</p><pre><code class="language-julia">mf = @model(h ~ vy + v1 + v2, c ~ vy + v1)
m = fit(HDMR, mf, covarsdf, counts)</code></pre><p>where the h ~ equation is the model for zeros (hurdle crossing) and c ~ is the model for positive counts</p><p>in either case we can get the coefficients matrix for each variable + intercept as usual with</p><pre><code class="language-julia">coefspos, coefszero = coef(m)</code></pre><p>By default we only return the AICc maximizing coefficients. To also get back the entire regularization paths, run</p><pre><code class="language-julia">paths = fit(HDMRPaths, mf, covarsdf, counts)

coef(paths, AllSeg())</code></pre><p>Syntax:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.HDMR" href="#HurdleDMR.HDMR"><code>HurdleDMR.HDMR</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract HDMR returned object</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.HDMRCoefs" href="#HurdleDMR.HDMRCoefs"><code>HurdleDMR.HDMRCoefs</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Relatively light object used to return HDMR results when we only care about estimated coefficients.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L24-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.HDMRPaths" href="#HurdleDMR.HDMRPaths"><code>HurdleDMR.HDMRPaths</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Relatively heavy object used to return HDMR results when we care about the regulatrization paths.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L11-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.hdmr-Union{Tuple{M}, Tuple{V}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{V,2}}, Tuple{AbstractArray{T,2},AbstractArray{V,2},Type{M}}} where M&lt;:HurdleDMR.TwoPartModel where V where T&lt;:AbstractFloat" href="#HurdleDMR.hdmr-Union{Tuple{M}, Tuple{V}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{V,2}}, Tuple{AbstractArray{T,2},AbstractArray{V,2},Type{M}}} where M&lt;:HurdleDMR.TwoPartModel where V where T&lt;:AbstractFloat"><code>HurdleDMR.hdmr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Shorthand for fit(HDMR,covars,counts). See also <a href="#StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat"><code>fit(::HDMR)</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L441">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.hdmrpaths-Union{Tuple{M}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2} where T}, Tuple{AbstractArray{T,2},AbstractArray{T,2} where T,Type{M}}} where M&lt;:HurdleDMR.TwoPartModel where T&lt;:AbstractFloat" href="#HurdleDMR.hdmrpaths-Union{Tuple{M}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2} where T}, Tuple{AbstractArray{T,2},AbstractArray{T,2} where T,Type{M}}} where M&lt;:HurdleDMR.TwoPartModel where T&lt;:AbstractFloat"><code>HurdleDMR.hdmrpaths</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Shorthand for fit(HDMRPaths,covars,counts). See also <a href="#StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat"><code>fit(::HDMRPaths)</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L267">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.ncoefspos-Tuple{HDMR}" href="#HurdleDMR.ncoefspos-Tuple{HDMR}"><code>HurdleDMR.ncoefspos</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Number of coefficient potentially including intercept used by model for positives</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L252">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.ncoefszero-Tuple{HDMR}" href="#HurdleDMR.ncoefszero-Tuple{HDMR}"><code>HurdleDMR.ncoefszero</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Number of coefficient potentially including intercept used by model for zeros</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L249">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.ncovarspos-Tuple{HDMR}" href="#HurdleDMR.ncovarspos-Tuple{HDMR}"><code>HurdleDMR.ncovarspos</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Number of covariates used for HDMR estimation of positives model</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.ncovarszero-Tuple{HDMR}" href="#HurdleDMR.ncovarszero-Tuple{HDMR}"><code>HurdleDMR.ncovarszero</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Number of covariates used for HDMR estimation of zeros model</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.posindic-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T" href="#HurdleDMR.posindic-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T"><code>HurdleDMR.posindic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">posindic(A)</code></pre><p>Returns an array of the same dimensions of indicators for positive entries in A.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L531-L535">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.posindic-Union{Tuple{SparseMatrixCSC{T,Ti} where Ti&lt;:Integer}, Tuple{T}} where T" href="#HurdleDMR.posindic-Union{Tuple{SparseMatrixCSC{T,Ti} where Ti&lt;:Integer}, Tuple{T}} where T"><code>HurdleDMR.posindic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Sparse version simply replaces all the non-zero values with ones.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L559">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.coef" href="#StatsBase.coef"><code>StatsBase.coef</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">coef(m::HDMRPaths, select::SegSelect=MinAICc())</code></pre><p>Returns all or selected coefficient matrices fitted with HDMR.</p><p><strong>Example:</strong></p><pre><code class="language-julia">  m = fit(HDMRPaths,covars,counts)
  coefspos, coefszero = coef(m, MinCVKfold{MinCVmse}(5))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L162-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.coef-Tuple{HDMRCoefs}" href="#StatsBase.coef-Tuple{HDMRCoefs}"><code>StatsBase.coef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">coef(m::HDMRCoefs)</code></pre><p>Returns the coefficient matrices fitted with HDMR using the segment selected during fit (MinAICc by default).</p><p><strong>Example:</strong></p><pre><code class="language-julia">  m = fit(HDMR,covars,counts)
  coefspos, coefszero = coef(m)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L140-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{M}, Tuple{T}, Tuple{Type{#s200} where #s200&lt;:HDMR{M},AbstractArray{T,2},AbstractArray{T,2} where T}} where M&lt;:HurdleDMR.TwoPartModel where T&lt;:AbstractFloat" href="#StatsBase.fit-Union{Tuple{M}, Tuple{T}, Tuple{Type{#s200} where #s200&lt;:HDMR{M},AbstractArray{T,2},AbstractArray{T,2} where T}} where M&lt;:HurdleDMR.TwoPartModel where T&lt;:AbstractFloat"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(HDMR,covars,counts; &lt;keyword arguments&gt;)
hdmr(covars,counts; &lt;keyword arguments&gt;)</code></pre><p>Fit a Hurdle Distributed Multinomial Regression (HDMR) of counts on covars.</p><p>HDMR fits independent hurdle lasso regressions to each column of counts to approximate a multinomial, picks a segement of each path, and returns a coefficient matrix (wrapped in HDMRCoefs) representing point estimates for the entire multinomial (includes the intercept if one was included).</p><p><strong>Example:</strong></p><pre><code class="language-julia">  m = fit(HDMR,covars,counts)</code></pre><p><strong>Arguments</strong></p><ul><li><code>covars</code> n-by-p matrix of covariates</li><li><code>counts</code> n-by-d matrix of counts (usually sparse)</li></ul><p><strong>Keywords</strong></p><ul><li><code>inpos=1:p</code> indices of covars columns included in model for positive counts</li><li><code>inzero=1:p</code> indices of covars columns included in model for zero counts</li><li><code>intercept::Bool=false</code> include a intercepts in each hurdle regression</li><li><code>parallel::Bool=true</code> parallelize the poisson fits</li><li><code>local_cluster::Bool=true</code> use local_cluster mode that shares memory across   parallel workers that is appropriate on a single multicore machine, or   remote cluster mode that is more appropriate when distributing across machines   for which sharing memory is costly.</li><li><code>verbose::Bool=true</code></li><li><code>showwarnings::Bool=false</code></li><li><code>select::SegSelect=MinAICc()</code> path segment selection criterion</li><li><code>kwargs...</code> additional keyword arguments passed along to fit(Hurdle,...)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L47-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{M}, Tuple{T}, Tuple{Type{HDMRPaths{M,X} where X},AbstractArray{T,2},AbstractArray{T,2} where T}} where M&lt;:HurdleDMR.TwoPartModel where T&lt;:AbstractFloat" href="#StatsBase.fit-Union{Tuple{M}, Tuple{T}, Tuple{Type{HDMRPaths{M,X} where X},AbstractArray{T,2},AbstractArray{T,2} where T}} where M&lt;:HurdleDMR.TwoPartModel where T&lt;:AbstractFloat"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(HDMRPaths,covars,counts; &lt;keyword arguments&gt;)
hdmrpaths(covars,counts; &lt;keyword arguments&gt;)</code></pre><p>Fit a Hurdle Distributed Multinomial Regression (HDMR) of counts on covars, and returns the entire regulatrization paths, which may be useful for plotting or picking coefficients other than the AICc optimal ones. Same arguments as <a href="#StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat"><code>fit(::HDMR)</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L86-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{T}, Tuple{Type{T},Model,Any,AbstractArray{T,2} where T,Vararg{Any,N} where N}} where T&lt;:HDMR" href="#StatsBase.fit-Union{Tuple{T}, Tuple{Type{T},Model,Any,AbstractArray{T,2} where T,Vararg{Any,N} where N}} where T&lt;:HDMR"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(HDMR,@model(h ~ x1 + x2, c ~ x1),df,counts; &lt;keyword arguments&gt;)</code></pre><p>Fits a HDMR but takes a model formula and dataframe instead of the covars matrix. See also <a href="#StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat"><code>fit(::HDMR)</code></a>.</p><p><code>h</code> and <code>c</code> on the lhs indicate the model for zeros and positives, respectively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L113-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.predict-Union{Tuple{T}, Tuple{HDMRPaths,AbstractArray{T,2}}} where T&lt;:AbstractFloat" href="#StatsBase.predict-Union{Tuple{T}, Tuple{HDMRPaths,AbstractArray{T,2}}} where T&lt;:AbstractFloat"><code>StatsBase.predict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">predict(m,newcovars; &lt;keyword arguments&gt;)</code></pre><p>Predict counts using a fitted HDMRPaths object and given newcovars.</p><p><strong>Example:</strong></p><pre><code class="language-julia">  m = fit(HDMRPaths,covars,counts)
  newcovars = covars[1:10,:]
  countshat = predict(m, newcovars; select=MinAICc())</code></pre><p><strong>Arguments</strong></p><ul><li><code>m::HDMRPaths</code> fitted DMRPaths model (HDMRCoefs currently not supported)</li><li><code>newcovars</code> n-by-p matrix of covariates of same dimensions used to fit m.</li></ul><p><strong>Keywords</strong></p><ul><li><code>select=MinAICc()</code> See <a href="#StatsBase.coef-Tuple{DMRCoefs}"><code>coef(::RegularizationPath)</code></a>.</li><li><code>kwargs...</code> additional keyword arguments passed along to predict() for each category j=1..size(counts,2)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hdmr.jl#L208-L228">source</a></section><h2><a class="nav-anchor" id="Sufficient-reduction-projection-1" href="#Sufficient-reduction-projection-1">Sufficient reduction projection</a></h2><p>A sufficient reduction projection summarizes the counts, much like a sufficient statistic, and is useful for reducing the d dimensional counts in a potentially much lower dimension matrix <code>z</code>.</p><p>To get a sufficient reduction projection in direction of vy for the above example</p><pre><code class="language-julia">z = srproj(m,counts,1,1)</code></pre><p>Here, the first column is the SR projection from the model for positive counts, the second is the the SR projection from the model for hurdle crossing (zeros), and the third is the total count for each observation.</p><p>Syntax:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.srproj" href="#HurdleDMR.srproj"><code>HurdleDMR.srproj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>srproj calculates the MNIR Sufficient Reduction projection from text counts on to the attribute dimensions of interest (covars in mnlm). In particular, for counts C, with row sums m, and mnlm coefficients φ<em>j corresponding to attribute j, z</em>j = C&#39;φ<em>j/m is the SR projection in the direction of j. The MNIR paper explains how V=[v</em>1 ... v<em>K], your original covariates/attributes, are independent of text counts C given SR projections Z=[z</em>1 ... z_K]. dir == nothing returns projections in all directions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/srproj.jl#L3-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.srproj-Union{Tuple{D}, Tuple{C}, Tuple{T}, Tuple{C,C,Any,D,D}} where D&lt;:Int64 where C&lt;:AbstractArray{T,2} where T" href="#HurdleDMR.srproj-Union{Tuple{D}, Tuple{C}, Tuple{T}, Tuple{C,C,Any,D,D}} where D&lt;:Int64 where C&lt;:AbstractArray{T,2} where T"><code>HurdleDMR.srproj</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>srproj for hurdle dmr takes two coefficent matrices coefspos, coefszero, and a two specific directions and returns an n-by-4 matrix Z = [zpos zzero m l]. dirpos = 0 omits positive counts projections and dirzero = 0 omits zero counts projections. Setting any of these to nothing will return projections in all directions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/srproj.jl#L118-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.srproj-Union{Tuple{D}, Tuple{HDMRCoefs,Any}, Tuple{HDMRCoefs,Any,D}, Tuple{HDMRCoefs,Any,D,D}} where D&lt;:Int64" href="#HurdleDMR.srproj-Union{Tuple{D}, Tuple{HDMRCoefs,Any}, Tuple{HDMRCoefs,Any,D}, Tuple{HDMRCoefs,Any,D,D}} where D&lt;:Int64"><code>HurdleDMR.srproj</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>srproj for hurdle dmr takes two coefficent matrices coefspos, coefszero, and a two specific directions and returns an n-by-4 matrix Z = [zpos zzero m l]. dirpos = 0 omits positive counts projections and dirzero = 0 omits zero counts projections. Setting any of these to nothing will return projections in all directions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/srproj.jl#L105-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.srproj-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any}, Tuple{AbstractArray{T,2},Any,Union{Nothing, Int64}}} where T" href="#HurdleDMR.srproj-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any}, Tuple{AbstractArray{T,2},Any,Union{Nothing, Int64}}} where T"><code>HurdleDMR.srproj</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>srproj calculates the MNIR Sufficient Reduction projection from text counts on to the attribute dimensions of interest (covars in mnlm). In particular, for counts C, with row sums m, and mnlm coefficients φ<em>j corresponding to attribute j, z</em>j = C&#39;φ<em>j/m is the SR projection in the direction of j. The MNIR paper explains how V=[v</em>1 ... v<em>K], your original covariates/attributes, are independent of text counts C given SR projections Z=[z</em>1 ... z_K]. dir == nothing returns projections in all directions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/srproj.jl#L19-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.srproj-Union{Tuple{T}, Tuple{AbstractArray{T,2},SparseMatrixCSC,Int64}} where T" href="#HurdleDMR.srproj-Union{Tuple{T}, Tuple{AbstractArray{T,2},SparseMatrixCSC,Int64}} where T"><code>HurdleDMR.srproj</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Like srproj but efficiently interates over a sparse counts matrix, and only projects in a single direction (dir).</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/srproj.jl#L41-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.srprojX-Union{Tuple{M}, Tuple{T}, Tuple{M,M,Any,Any,Int64}} where M&lt;:AbstractArray{T,2} where T" href="#HurdleDMR.srprojX-Union{Tuple{M}, Tuple{T}, Tuple{M,M,Any,Any,Int64}} where M&lt;:AbstractArray{T,2} where T"><code>HurdleDMR.srprojX</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Builds the design matrix X for predicting covar in direction projdir   hdmr version   Assumes that covars include all variables for both positives and zeros models   and indicates which variables are where with the index arrays inpos and inzero.   inz=[1,2] if both zpos and zzero are included   inz=[2] if zpos is dropped due to collinearity</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/srproj.jl#L166-L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.srprojX-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any,Any,Any}} where T" href="#HurdleDMR.srprojX-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any,Any,Any}} where T"><code>HurdleDMR.srprojX</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Builds the design matrix X for predicting covar in direction projdir   dmr version   inz=[1] and testrank=false always for dmr, so variables are ignored and only here for convinence     of unified calling function</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/srproj.jl#L72-L77">source</a></section><h2><a class="nav-anchor" id="Counts-Inverse-Regression-(CIR)-1" href="#Counts-Inverse-Regression-(CIR)-1">Counts Inverse Regression (CIR)</a></h2><p>Counts inverse regression allows us to predict a covariate with the counts and other covariates. Here we use hdmr for the backward regression and another model for the forward regression. This can be accomplished with a single command, by fitting a CIR{HDMR,FM} where the forward model is FM &lt;: RegressionModel.</p><pre><code class="language-julia">cir = fit(CIR{HDMR,LinearModel},mf,covarsdf,counts,:vy; nocounts=true)</code></pre><p>where the <code>nocounts=true</code> means we also fit a benchmark model without counts.</p><p>we can get the forward and backward model coefficients with</p><pre><code class="language-julia">coefbwd(cir)
coeffwd(cir)</code></pre><p>The fitted model can be used to predict vy with new data</p><pre><code class="language-julia">yhat = predict(cir, covarsdf[1:10,:], counts[1:10,:])</code></pre><p>We can also predict only with the other covariates, which in this case is just a linear regression</p><pre><code class="language-julia">yhat_nocounts = predict(cir, covarsdf[1:10,:], counts[1:10,:]; nocounts=true)</code></pre><p>Syntax:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.CIR" href="#HurdleDMR.CIR"><code>HurdleDMR.CIR</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Counts inverse regression (CIR) model supports both multinomial and hurdle inverse regressions and holds both the inverse and forward regression model estimates</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/invreg.jl#L1-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.coefbwd-Tuple{CIR}" href="#HurdleDMR.coefbwd-Tuple{CIR}"><code>HurdleDMR.coefbwd</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns coefficients for backward model for counts as function of covariates</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/invreg.jl#L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.coeffwd-Tuple{CIR}" href="#HurdleDMR.coeffwd-Tuple{CIR}"><code>HurdleDMR.coeffwd</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns coefficients of forward regression model. Set nocounts=true to get coefficients for the benchmark model without counts.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/invreg.jl#L226-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{C}, Tuple{FM}, Tuple{BM}, Tuple{Type{C},Model,Any,AbstractArray{T,2} where T,Symbol,Vararg{Any,N} where N}} where C&lt;:CIR{BM,FM} where FM&lt;:StatsBase.RegressionModel where BM&lt;:DMR" href="#StatsBase.fit-Union{Tuple{C}, Tuple{FM}, Tuple{BM}, Tuple{Type{C},Model,Any,AbstractArray{T,2} where T,Symbol,Vararg{Any,N} where N}} where C&lt;:CIR{BM,FM} where FM&lt;:StatsBase.RegressionModel where BM&lt;:DMR"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(CIR{DMR,FM},m,df,counts,projdir[,fmargs...]; &lt;keyword arguments&gt;)</code></pre><p>Version of fit(CIR{DMR,FM}...) that takes a @model() and a dataframe instead of a covars matrix, and a projdir::Symbol specifies the dependent variable. See also fit(CIR...).</p><p><strong>Example:</strong></p><pre><code class="language-julia">  m = fit(CIR{DMR,LinearModel}, @model(c~x1+x2), df, counts, :x1; nocounts=true)</code></pre><p>where <code>c~</code> is the model for counts. <code>x1</code> (<code>projdir</code>) is the variable to predict. We can then predict with a dataframe as well</p><pre><code class="language-julia">  yhat = predict(m, df, counts)
  yhatnc = predict(m, df, counts; nocounts=true)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/invreg.jl#L75-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{C}, Tuple{FM}, Tuple{BM}, Tuple{Type{C},Model,Any,AbstractArray{T,2} where T,Symbol,Vararg{Any,N} where N}} where C&lt;:CIR{BM,FM} where FM&lt;:StatsBase.RegressionModel where BM&lt;:HDMR" href="#StatsBase.fit-Union{Tuple{C}, Tuple{FM}, Tuple{BM}, Tuple{Type{C},Model,Any,AbstractArray{T,2} where T,Symbol,Vararg{Any,N} where N}} where C&lt;:CIR{BM,FM} where FM&lt;:StatsBase.RegressionModel where BM&lt;:HDMR"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(CIR{HDMR,FM},m,df,counts,projdir[,fmargs...]; &lt;keyword arguments&gt;)</code></pre><p>Version of fit(CIR{HDMR,FM}...) that takes a @model() and a dataframe instead of a covars matrix, and a projdir::Symbol specifies the dependent variable. See also fit(CIR...).</p><p><strong>Example:</strong></p><pre><code class="language-julia">  m = fit(CIR{HDMR,LinearModel}, @model(h~x1+x2, c~x1), df, counts, :x1; nocounts=true)</code></pre><p>where <code>h~</code> is the model for zeros, <code>c~</code> is the model for positives. <code>x1</code> (<code>projdir</code>) is the variable to predict. We can then predict with a dataframe as well</p><pre><code class="language-julia">  yhat = predict(m, df, counts)
  yhatnc = predict(m, df, counts; nocounts=true)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/invreg.jl#L110-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{C}, Tuple{FM}, Tuple{BM}, Tuple{V}, Tuple{T}, Tuple{Type{C},AbstractArray{T,2},AbstractArray{V,2},Int64,Vararg{Any,N} where N}} where C&lt;:CIR{BM,FM} where FM&lt;:StatsBase.RegressionModel where BM&lt;:DCR where V where T&lt;:AbstractFloat" href="#StatsBase.fit-Union{Tuple{C}, Tuple{FM}, Tuple{BM}, Tuple{V}, Tuple{T}, Tuple{Type{C},AbstractArray{T,2},AbstractArray{V,2},Int64,Vararg{Any,N} where N}} where C&lt;:CIR{BM,FM} where FM&lt;:StatsBase.RegressionModel where BM&lt;:DCR where V where T&lt;:AbstractFloat"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(::CIR{BM,FM},covars,counts,projdir[,fmargs...]; &lt;keyword arguments&gt;)</code></pre><p>Fit a Counts Inverse Regression (CIR) of <code>covars[:,projdir] ~ counts + covars[:,~projdir]</code>.</p><p>CIR involves three steps:</p><ol><li>Fit a backward regression model BM&lt;:DCR: counts ~ covars</li><li>Calculate an sufficient reduction projection in direction projdir</li><li>Fit a forward regression model FM&lt;:RegressionModel:</li></ol><pre><code class="language-none">covars[:,projdir] ~ srproj(counts) + covars[:,~projdir]</code></pre><p><strong>Example:</strong></p><pre><code class="language-julia">  m = fit(CIR{DMR,LinearModel}, covars, counts, 1; nocounts=true)
  yhat = predict(m, covars, counts)
  yhatnc = predict(m, covars, counts; nocounts=true)</code></pre><p><strong>Arguments</strong></p><ul><li><code>covars</code> n-by-p matrix of covariates</li><li><code>counts</code> n-by-d matrix of counts (usually sparse)</li><li><code>projdir</code> index of covars column used as dependent variable in forward model</li><li><code>fmargs...</code> optional arguments passed along to the forward regression model</li></ul><p><strong>Keywords</strong></p><ul><li><code>nocounts::Bool=false</code> whether to also fit a benchmark model without counts</li><li><code>bmkwargs...</code> keyword arguments passed along to the backward regression model</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/invreg.jl#L20-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.predict-Union{Tuple{MM}, Tuple{C}, Tuple{D}, Tuple{M}, Tuple{T}, Tuple{MM,Any,AbstractArray{T,2} where T}} where MM&lt;:Union{TableCountsRegressionModel{M,D,C}, CIR} where C where D where M&lt;:CIR where T" href="#StatsBase.predict-Union{Tuple{MM}, Tuple{C}, Tuple{D}, Tuple{M}, Tuple{T}, Tuple{MM,Any,AbstractArray{T,2} where T}} where MM&lt;:Union{TableCountsRegressionModel{M,D,C}, CIR} where C where D where M&lt;:CIR where T"><code>StatsBase.predict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Predict using a fitted Counts inverse regression (CIR) given new covars dataframe and counts. See also <a href="#StatsBase.predict-Union{Tuple{T}, Tuple{DMRPaths,AbstractArray{T,2}}} where T&lt;:AbstractFloat"><code>predict(::CIR)</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/invreg.jl#L184-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.predict-Union{Tuple{V}, Tuple{T}, Tuple{CIR,AbstractArray{T,2},AbstractArray{V,2}}} where V where T&lt;:AbstractFloat" href="#StatsBase.predict-Union{Tuple{V}, Tuple{T}, Tuple{CIR,AbstractArray{T,2},AbstractArray{V,2}}} where V where T&lt;:AbstractFloat"><code>StatsBase.predict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Predict using a fitted Counts inverse regression (CIR) given new covars and counts.</p><p><strong>Keywords</strong></p><ul><li>Set <code>nocounts=true</code> to predict using a benchmark model without counts.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/invreg.jl#L160-L165">source</a></section><h2><a class="nav-anchor" id="Hurdle-1" href="#Hurdle-1">Hurdle</a></h2><p>This package also provides a regularized Hurdle model (Mullahy, 1986) that can be fit using a fast coordinate decent algorithm, or simply by running two <code>fit(GeneralizedLinearModel,...)</code> regressions, one for each of its two parts.</p><p>Syntax:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.Hurdle" href="#HurdleDMR.Hurdle"><code>HurdleDMR.Hurdle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Hurdle returned object</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hurdle.jl#L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.MinCVKfold" href="#HurdleDMR.MinCVKfold"><code>HurdleDMR.MinCVKfold</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Selects the RegularizationPath segment according to <code>CVSegSelect</code> with <code>k</code>-fold cross-validation</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hurdle.jl#L376">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.coef-Tuple{HurdleDMR.TwoPartModel}" href="#StatsBase.coef-Tuple{HurdleDMR.TwoPartModel}"><code>StatsBase.coef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">coef(m::Hurdle; select=MinAICc())</code></pre><p>Returns a selected segment of the coefficient matrices of the fitted the TwoPartModel.</p><p><strong>Example:</strong></p><pre><code class="language-julia">  m = fit(Hurdle,GeneralizedLinearModel,X,y; Xpos=Xpos)
  coefspos, coefszero = coef(m)</code></pre><p><strong>Keywords</strong></p><ul><li><code>kwargs...</code> are passed along to two coef() calls on the two model parts.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hurdle.jl#L341-L354">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.coef-Union{Tuple{S}, Tuple{RegularizationPath,MinCVKfold{S}}} where S&lt;:Lasso.CVSegSelect" href="#StatsBase.coef-Union{Tuple{S}, Tuple{RegularizationPath,MinCVKfold{S}}} where S&lt;:Lasso.CVSegSelect"><code>StatsBase.coef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Selects the RegularizationPath segment coefficients according to <code>S</code> with <code>k</code>-fold cross-validation</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hurdle.jl#L381">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.coef-Union{Tuple{S}, Tuple{TwoPartModel,MinCVKfold{S}}} where S&lt;:Lasso.CVSegSelect" href="#StatsBase.coef-Union{Tuple{S}, Tuple{TwoPartModel,MinCVKfold{S}}} where S&lt;:Lasso.CVSegSelect"><code>StatsBase.coef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Selects the RegularizationPath segment coefficients according to <code>S</code> with <code>k</code>-fold cross-validation</p></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hurdle.jl#L389">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{M}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link,Link}} where M&lt;:StatsBase.RegressionModel" href="#StatsBase.fit-Union{Tuple{M}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link,Link}} where M&lt;:StatsBase.RegressionModel"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(Hurdle,M,f,df; fpos=Xpos, &lt;keyword arguments&gt;)</code></pre><p>Takes dataframe and two formulas, one for each model part. Otherwise same arguments as <a href="#StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat"><code>fit(::Hurdle)</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia">  fit(Hurdle,GeneralizedLinearModel,@formula(y ~ x1*x2), df; fpos=@formula(y ~ x1*x2+x3))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hurdle.jl#L267-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit-Union{Tuple{V}, Tuple{T}, Tuple{M}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link,Link}} where V&lt;:(AbstractArray{T,1} where T&lt;:AbstractFloat) where T&lt;:AbstractFloat where M&lt;:StatsBase.RegressionModel" href="#StatsBase.fit-Union{Tuple{V}, Tuple{T}, Tuple{M}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link,Link}} where V&lt;:(AbstractArray{T,1} where T&lt;:AbstractFloat) where T&lt;:AbstractFloat where M&lt;:StatsBase.RegressionModel"><code>StatsBase.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(Hurdle,M,X,y; Xpos=Xpos, &lt;keyword arguments&gt;)</code></pre><p>Fit a Hurdle (Mullahy, 1986) of count vector y on X with potentially another covariates matrix Xpos used to model positive counts.</p><p><strong>Example with GLM:</strong></p><pre><code class="language-julia">  m = fit(Hurdle,GeneralizedLinearModel,X,y; Xpos=Xpos)
  yhat = predict(m, X; Xpos=Xpos)</code></pre><p><strong>Example with Lasso regularization:</strong></p><pre><code class="language-julia">  m = fit(Hurdle,GammaLassoPath,X,y; Xpos=Xpos)
  yhat = predict(m, X; Xpos=Xpos, select=MinAICc())</code></pre><p><strong>Arguments</strong></p><ul><li><code>M::RegressionModel</code></li><li><code>counts</code> n-by-d matrix of counts (usually sparse)</li><li><code>dzero::UnivariateDistribution = Binomial()</code> distribution for zeros model</li><li><code>dpos::UnivariateDistribution = PositivePoisson()</code> distribution for positives model</li><li><code>lzero::Link=canonicallink(dzero)</code> link function for zeros model</li><li><code>lpos::Link=canonicallink(dpos)</code> link function for positives model</li></ul><p><strong>Keywords</strong></p><ul><li><code>Xpos::Union{AbstractMatrix{T},Nothing} = nothing</code> covariates matrix for positives model or nothing to use X for both parts</li><li><code>dofit::Bool = true</code> fit the model or just construct its shell</li><li><code>wts::V = ones(y)</code> observation weights</li><li><code>offsetzero::AbstractVector = similar(y, 0)</code> offsets for zeros model</li><li><code>offsetpos::AbstractVector = similar(y, 0)</code> offsets for positives model</li><li><code>offset::AbstractVector = similar(y, 0)</code> offsets for both model parts</li><li><code>verbose::Bool=true</code></li><li><code>showwarnings::Bool=false</code></li><li><code>fitargs...</code> additional keyword arguments passed along to fit(M,...)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hurdle.jl#L193-L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.predict-Union{Tuple{T}, Tuple{TwoPartModel,AbstractArray{T,2}}} where T&lt;:AbstractFloat" href="#StatsBase.predict-Union{Tuple{T}, Tuple{TwoPartModel,AbstractArray{T,2}}} where T&lt;:AbstractFloat"><code>StatsBase.predict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">predict(m,X; Xpos=Xpos, &lt;keyword arguments&gt;)</code></pre><p>Predict using a fitted TwoPartModel given new X (and potentially Xpos).</p><p><strong>Example with GLM:</strong></p><pre><code class="language-julia">  m = fit(Hurdle,GeneralizedLinearModel,X,y; Xpos=Xpos)
  yhat = predict(m, X; Xpos=Xpos)</code></pre><p><strong>Example with Lasso regularization:</strong></p><pre><code class="language-julia">  m = fit(Hurdle,GammaLassoPath,X,y; Xpos=Xpos)
  yhat = predict(m, X; Xpos=Xpos, select=MinAICc())</code></pre><p><strong>Arguments</strong></p><ul><li><code>m::Hurdle</code> fitted Hurdle model</li><li><code>X</code> n-by-p matrix of covariates of same dimensions used to fit m.</li></ul><p><strong>Keywords</strong></p><ul><li><code>Xpos::Union{AbstractMatrix{T},Nothing} = nothing</code> covariates matrix for positives model or nothing to use X for both parts</li><li><code>kwargs...</code> additional keyword arguments passed along to predict() for each of the two model parts.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/hurdle.jl#L403-L429">source</a></section><h2><a class="nav-anchor" id="Positive-Poisson-1" href="#Positive-Poisson-1">Positive Poisson</a></h2><p>This package also implements the <code>PositivePoisson</code> distribution and the GLM necessary methods to facilitate fit with <a href="@ref"><code>fit(::GeneralizedLinearModel</code></a>.</p><p>Syntax:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HurdleDMR.PositivePoisson" href="#HurdleDMR.PositivePoisson"><code>HurdleDMR.PositivePoisson</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PositivePoisson(λ)</code></pre><p>A <em>PositivePoisson distribution</em> (aka zero-truncated Poisson, ZTP) descibes the number of independent events occurring within a unit time interval, given the average rate of occurrence <code>λ</code> and, importantly, given that the number is not zero.</p><p><span>$P(X = k) = \frac{λ^k}{k!(1-e^{-λ})} e^{-λ}, \quad \text{ for } k = 1,2,\ldots.$</span></p><pre><code class="language-julia">PositivePoisson()        # PositivePoisson distribution with rate parameter 1
PositivePoisson(lambda)       # PositivePoisson distribution with rate parameter lambda

params(d)        # Get the parameters, i.e. (λ,)
mean(d)          # Get the mean arrival rate, i.e. λ</code></pre><p>External links:</p><ul><li><a href="https://en.wikipedia.org/wiki/Zero-truncated_Poisson_distribution">PositivePoisson distribution on Wikipedia</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/AsafManela/HurdleDMR.jl/blob/a067b8e35014d90b530d93fb97912a16eeb23c63/src/positive_poisson.jl#L8-L29">source</a></section><h2><a class="nav-anchor" id="API-/-Index-1" href="#API-/-Index-1">API / Index</a></h2><ul><li><a href="#HurdleDMR.CIR"><code>HurdleDMR.CIR</code></a></li><li><a href="#HurdleDMR.DCR"><code>HurdleDMR.DCR</code></a></li><li><a href="#HurdleDMR.DMR"><code>HurdleDMR.DMR</code></a></li><li><a href="#HurdleDMR.DMRCoefs"><code>HurdleDMR.DMRCoefs</code></a></li><li><a href="#HurdleDMR.DMRPaths"><code>HurdleDMR.DMRPaths</code></a></li><li><a href="#HurdleDMR.HDMR"><code>HurdleDMR.HDMR</code></a></li><li><a href="#HurdleDMR.HDMRCoefs"><code>HurdleDMR.HDMRCoefs</code></a></li><li><a href="#HurdleDMR.HDMRPaths"><code>HurdleDMR.HDMRPaths</code></a></li><li><a href="#HurdleDMR.Hurdle"><code>HurdleDMR.Hurdle</code></a></li><li><a href="#HurdleDMR.MinCVKfold"><code>HurdleDMR.MinCVKfold</code></a></li><li><a href="#HurdleDMR.PositivePoisson"><code>HurdleDMR.PositivePoisson</code></a></li><li><a href="#Distributions.ncategories-Tuple{DCR}"><code>Distributions.ncategories</code></a></li><li><a href="#HurdleDMR.coefbwd-Tuple{CIR}"><code>HurdleDMR.coefbwd</code></a></li><li><a href="#HurdleDMR.coeffwd-Tuple{CIR}"><code>HurdleDMR.coeffwd</code></a></li><li><a href="#HurdleDMR.dmr-Union{Tuple{V}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{V,2}}} where V where T&lt;:AbstractFloat"><code>HurdleDMR.dmr</code></a></li><li><a href="#HurdleDMR.dmrpaths-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2} where T}} where T&lt;:AbstractFloat"><code>HurdleDMR.dmrpaths</code></a></li><li><a href="#HurdleDMR.hasintercept-Tuple{DCR}"><code>HurdleDMR.hasintercept</code></a></li><li><a href="#HurdleDMR.hdmr-Union{Tuple{M}, Tuple{V}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{V,2}}, Tuple{AbstractArray{T,2},AbstractArray{V,2},Type{M}}} where M&lt;:HurdleDMR.TwoPartModel where V where T&lt;:AbstractFloat"><code>HurdleDMR.hdmr</code></a></li><li><a href="#HurdleDMR.hdmrpaths-Union{Tuple{M}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2} where T}, Tuple{AbstractArray{T,2},AbstractArray{T,2} where T,Type{M}}} where M&lt;:HurdleDMR.TwoPartModel where T&lt;:AbstractFloat"><code>HurdleDMR.hdmrpaths</code></a></li><li><a href="#HurdleDMR.ncoefs-Tuple{DMR}"><code>HurdleDMR.ncoefs</code></a></li><li><a href="#HurdleDMR.ncoefspos-Tuple{HDMR}"><code>HurdleDMR.ncoefspos</code></a></li><li><a href="#HurdleDMR.ncoefszero-Tuple{HDMR}"><code>HurdleDMR.ncoefszero</code></a></li><li><a href="#HurdleDMR.ncovars-Tuple{DMR}"><code>HurdleDMR.ncovars</code></a></li><li><a href="#HurdleDMR.ncovarspos-Tuple{HDMR}"><code>HurdleDMR.ncovarspos</code></a></li><li><a href="#HurdleDMR.ncovarszero-Tuple{HDMR}"><code>HurdleDMR.ncovarszero</code></a></li><li><a href="#HurdleDMR.posindic-Union{Tuple{SparseMatrixCSC{T,Ti} where Ti&lt;:Integer}, Tuple{T}} where T"><code>HurdleDMR.posindic</code></a></li><li><a href="#HurdleDMR.posindic-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T"><code>HurdleDMR.posindic</code></a></li><li><a href="#HurdleDMR.srproj-Union{Tuple{D}, Tuple{C}, Tuple{T}, Tuple{C,C,Any,D,D}} where D&lt;:Int64 where C&lt;:AbstractArray{T,2} where T"><code>HurdleDMR.srproj</code></a></li><li><a href="#HurdleDMR.srproj-Union{Tuple{T}, Tuple{AbstractArray{T,2},SparseMatrixCSC,Int64}} where T"><code>HurdleDMR.srproj</code></a></li><li><a href="#HurdleDMR.srproj-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any}, Tuple{AbstractArray{T,2},Any,Union{Nothing, Int64}}} where T"><code>HurdleDMR.srproj</code></a></li><li><a href="#HurdleDMR.srproj"><code>HurdleDMR.srproj</code></a></li><li><a href="#HurdleDMR.srproj-Union{Tuple{D}, Tuple{HDMRCoefs,Any}, Tuple{HDMRCoefs,Any,D}, Tuple{HDMRCoefs,Any,D,D}} where D&lt;:Int64"><code>HurdleDMR.srproj</code></a></li><li><a href="#HurdleDMR.srprojX-Union{Tuple{M}, Tuple{T}, Tuple{M,M,Any,Any,Int64}} where M&lt;:AbstractArray{T,2} where T"><code>HurdleDMR.srprojX</code></a></li><li><a href="#HurdleDMR.srprojX-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any,Any,Any}} where T"><code>HurdleDMR.srprojX</code></a></li><li><a href="#StatsBase.coef"><code>StatsBase.coef</code></a></li><li><a href="#StatsBase.coef-Tuple{HurdleDMR.TwoPartModel}"><code>StatsBase.coef</code></a></li><li><a href="#StatsBase.coef-Tuple{DMRCoefs}"><code>StatsBase.coef</code></a></li><li><a href="#StatsBase.coef-Tuple{HDMRCoefs}"><code>StatsBase.coef</code></a></li><li><a href="#StatsBase.coef-Union{Tuple{S}, Tuple{RegularizationPath,MinCVKfold{S}}} where S&lt;:Lasso.CVSegSelect"><code>StatsBase.coef</code></a></li><li><a href="#StatsBase.coef-Union{Tuple{S}, Tuple{TwoPartModel,MinCVKfold{S}}} where S&lt;:Lasso.CVSegSelect"><code>StatsBase.coef</code></a></li><li><a href="#StatsBase.fit-Union{Tuple{D}, Tuple{T}, Tuple{Type{D},AbstractArray{T,2},AbstractArray{T,2} where T}} where D&lt;:DMR where T&lt;:AbstractFloat"><code>StatsBase.fit</code></a></li><li><a href="#StatsBase.fit-Union{Tuple{V}, Tuple{T}, Tuple{M}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link}, Tuple{Type{Hurdle},Type{M},AbstractArray{T,2},V,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link,Link}} where V&lt;:(AbstractArray{T,1} where T&lt;:AbstractFloat) where T&lt;:AbstractFloat where M&lt;:StatsBase.RegressionModel"><code>StatsBase.fit</code></a></li><li><a href="#StatsBase.fit-Union{Tuple{M}, Tuple{T}, Tuple{Type{#s200} where #s200&lt;:HDMR{M},AbstractArray{T,2},AbstractArray{T,2} where T}} where M&lt;:HurdleDMR.TwoPartModel where T&lt;:AbstractFloat"><code>StatsBase.fit</code></a></li><li><a href="#StatsBase.fit-Union{Tuple{C}, Tuple{FM}, Tuple{BM}, Tuple{Type{C},Model,Any,AbstractArray{T,2} where T,Symbol,Vararg{Any,N} where N}} where C&lt;:CIR{BM,FM} where FM&lt;:StatsBase.RegressionModel where BM&lt;:HDMR"><code>StatsBase.fit</code></a></li><li><a href="#StatsBase.fit-Union{Tuple{T}, Tuple{Type{T},Model,Any,AbstractArray{T,2} where T}} where T&lt;:DMR"><code>StatsBase.fit</code></a></li><li><a href="#StatsBase.fit-Union{Tuple{T}, Tuple{Type{T},Model,Any,AbstractArray{T,2} where T,Vararg{Any,N} where N}} where T&lt;:HDMR"><code>StatsBase.fit</code></a></li><li><a href="#StatsBase.fit-Union{Tuple{C}, Tuple{FM}, Tuple{BM}, Tuple{Type{C},Model,Any,AbstractArray{T,2} where T,Symbol,Vararg{Any,N} where N}} where C&lt;:CIR{BM,FM} where FM&lt;:StatsBase.RegressionModel where BM&lt;:DMR"><code>StatsBase.fit</code></a></li><li><a href="#StatsBase.fit-Union{Tuple{M}, Tuple{T}, Tuple{Type{HDMRPaths{M,X} where X},AbstractArray{T,2},AbstractArray{T,2} where T}} where M&lt;:HurdleDMR.TwoPartModel where T&lt;:AbstractFloat"><code>StatsBase.fit</code></a></li><li><a href="#StatsBase.fit-Union{Tuple{M}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link}, Tuple{Type{Hurdle},Type{M},FormulaTerm,Any,Distribution{Univariate,S} where S&lt;:ValueSupport,Distribution{Univariate,S} where S&lt;:ValueSupport,Link,Link}} where M&lt;:StatsBase.RegressionModel"><code>StatsBase.fit</code></a></li><li><a href="#StatsBase.fit-Union{Tuple{T}, Tuple{Type{DMRPaths},AbstractArray{T,2},AbstractArray{T,2} where T}} where T&lt;:AbstractFloat"><code>StatsBase.fit</code></a></li><li><a href="#StatsBase.fit-Union{Tuple{C}, Tuple{FM}, Tuple{BM}, Tuple{V}, Tuple{T}, Tuple{Type{C},AbstractArray{T,2},AbstractArray{V,2},Int64,Vararg{Any,N} where N}} where C&lt;:CIR{BM,FM} where FM&lt;:StatsBase.RegressionModel where BM&lt;:DCR where V where T&lt;:AbstractFloat"><code>StatsBase.fit</code></a></li><li><a href="#StatsBase.nobs-Tuple{DCR}"><code>StatsBase.nobs</code></a></li><li><a href="#StatsBase.predict-Union{Tuple{V}, Tuple{T}, Tuple{CIR,AbstractArray{T,2},AbstractArray{V,2}}} where V where T&lt;:AbstractFloat"><code>StatsBase.predict</code></a></li><li><a href="#StatsBase.predict-Union{Tuple{T}, Tuple{DMRPaths,AbstractArray{T,2}}} where T&lt;:AbstractFloat"><code>StatsBase.predict</code></a></li><li><a href="#StatsBase.predict-Union{Tuple{T}, Tuple{HDMRPaths,AbstractArray{T,2}}} where T&lt;:AbstractFloat"><code>StatsBase.predict</code></a></li><li><a href="#StatsBase.predict-Union{Tuple{T}, Tuple{TwoPartModel,AbstractArray{T,2}}} where T&lt;:AbstractFloat"><code>StatsBase.predict</code></a></li><li><a href="#StatsBase.predict-Union{Tuple{MM}, Tuple{C}, Tuple{D}, Tuple{M}, Tuple{T}, Tuple{MM,Any,AbstractArray{T,2} where T}} where MM&lt;:Union{TableCountsRegressionModel{M,D,C}, CIR} where C where D where M&lt;:CIR where T"><code>StatsBase.predict</code></a></li></ul><footer><hr/><a class="next" href="tutorials/"><span class="direction">Next</span><span class="title">Tutorials</span></a></footer></article></body></html>
